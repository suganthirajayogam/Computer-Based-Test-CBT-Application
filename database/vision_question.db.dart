import 'dart:io';

import 'package:path/path.dart' as p;

import 'package:sqflite/sqflite.dart';

import '../models/vis_ques_model.dart';
 
class VisionQuestionDB {

  static final VisionQuestionDB instance = VisionQuestionDB._init();

  static Database? _database;
 
  VisionQuestionDB._init();
 
  Future<Database> get database async {

    if (_database != null) return _database!;

    _database = await _initDB();

    return _database!;

  }
 
  Future<Database> _initDB() async {

    try {

      final directory = Directory.current;

      final dbPath = p.join(directory.path, 'CBT', 'visionmoduledb.db');

      print('üìÇ Using Vision DB path: $dbPath');
 
      final db = await openDatabase(

        dbPath,

        version: 1,

        onCreate: _createDB,

        onOpen: (db) => print('‚úÖ Vision DB Opened Successfully'),

      );
 
      print('‚úÖ visionmoduledb.db initialized');

      return db;

    } catch (e) {

      print('‚ùå Failed to initialize Vision DB: $e');

      rethrow;

    }

  }
 
  Future _createDB(Database db, int version) async {

    try {

      await db.execute('''

        CREATE TABLE vision_questions (

          id INTEGER PRIMARY KEY AUTOINCREMENT,

          module TEXT,

          question_text TEXT,

          image_path TEXT,

          correct_answer TEXT,

          allreasons TEXT,

          reasons TEXT,

          video_path TEXT

        )

      ''');

      print('‚úÖ vision_questions table created');
 
      await db.execute('''

        CREATE TABLE IF NOT EXISTS vision_reasons (

          id INTEGER PRIMARY KEY AUTOINCREMENT,

          reason_text TEXT UNIQUE

        )

      ''');

      print('‚úÖ vision_reasons table created');
 
    } catch (e) {

      print('‚ùå Error creating tables: $e');

    }

  }
 
  Future<void> insertvisionQuestion(VisionQuestionModel question) async {

    final db = await instance.database;
 
    final id = await db.insert('vision_questions', question.toMap());
 
    print('\n‚úÖ Question Inserted Successfully!');

    print('üÜî ID: $id');

    print('üì¶ Module: ${question.module}');

    print('‚ùì Question: ${question.questionText}');

    print('üì∑ Image: ${question.imagePath}');

    print('üéûÔ∏è Video: ${question.videoPath}');

    print('‚úÖ Correct Answer: ${question.correctAnswer}');

    print('üìã All Reasons: ${question.allReasons.join(", ")}');

    print('üìç Selected Reasons: ${question.reasons.isNotEmpty ? question.reasons.join(", ") : "None"}\n');

  }
 
  Future<int> updateVisionQuestion(int id, Map<String, dynamic> updatedData) async {

    try {

      final db = await instance.database;

      return await db.update(

        'vision_questions',

        updatedData,

        where: 'id = ?',

        whereArgs: [id],

      );

    } catch (e) {

      print('‚ùå Error updating vision question: $e');

      return 0;

    }

  }
 
  Future<int> deleteVisionQuestion(int id) async {

    try {

      final db = await instance.database;

      return await db.delete(

        'vision_questions',

        where: 'id = ?',

        whereArgs: [id],

      );

    } catch (e) {

      print('‚ùå Error deleting vision question: $e');

      return 0;

    }

  }
 
  Future<void> deleteQuestionById(int id) async {

    final db = await instance.database;

    await db.delete('vision_questions', where: 'id = ?', whereArgs: [id]);

  }
 
  Future<void> debugPrintAllQuestions() async {

    final db = await instance.database;

    final result = await db.query('vision_questions');

    print("üóÇÔ∏è All questions in DB:");

    for (final row in result) {

      print(row);

    }

  }
 
  Future close() async {

    final db = await instance.database;

    await db.close();

    print('üõë visionmoduledb.db closed');

  }
 
  Future<void> printSchema() async {

    final db = await instance.database;

    final result = await db.rawQuery('PRAGMA table_info(vision_questions)');

    print('üìä Table schema for vision_questions:');

    for (var row in result) {

      print(row);

    }

  }
 
  Future<List<VisionQuestionModel>> getQuestionsByModule(String module) async {

    final db = await instance.database;

    final result = await db.query(

      'vision_questions',

      where: 'module = ?',

      whereArgs: [module],

    );
 
    for (final row in result) {

      print('üì• Raw DB row: $row');

    }
 
    final questions = result.map((e) => VisionQuestionModel.fromMap(e)).toList();
 
    for (final q in questions) {

      print('üì¶ Question: ${q.questionText}, AllReasons: ${q.allReasons}, Selected: ${q.reasons}');

    }
 
    return questions;

  }
 
  // ‚úÖ GLOBAL REASON TABLE FUNCTIONS
 
  Future<void> insertReason(String reason) async {

    final db = await instance.database;

    try {

      await db.insert(

        'vision_reasons',

        {'reason_text': reason},

        conflictAlgorithm: ConflictAlgorithm.ignore,

      );

      print('‚ûï Reason added: $reason');

    } catch (e) {

      print('‚ùå Error inserting reason: $e');

    }

  }
 
  Future<List<String>> getAllReasons() async {

    final db = await instance.database;

    final result = await db.query('vision_reasons', orderBy: 'reason_text ASC');

    return result.map((row) => row['reason_text'] as String).toList();

  }
 
  Future<void> deleteReason(String reason) async {

    final db = await instance.database;

    await db.delete('vision_reasons', where: 'reason_text = ?', whereArgs: [reason]);

    print('üóëÔ∏è Reason deleted: $reason');

  }

}

 
